Lockstep Protocol Project Report
Rafael Bravo

  ABSTRACT:
  My project was to design a lockstep protocol framework that can be used to run browser based multi-user applications. the protocol can be hosted on a server that brokers connections between clients.
  
  INTRODUCTION:
  Lockstep protocol is a peer-to-peer networking framework that allows mutliple peers to change the state of a single system without needing to send state information. This is accomplished by each peer having an identical copy of the system state. states are only advanced when the intentions of the other peers are known. Thus changes made by peers affect all copies of the system simultaneously, maintaining synchrony accross machines.
  Lockstep protocol has been around since 1985, when it was first introduced in simple peer-to-peer mutliplayer videogames. These games would require installation, and users would then connect to each other by exchanging IP addresses. The advent of webrtc technology into web browsers in recent years (first released in 2011) makes establishing a peer to peer connection completely in the browser possible for the first time.
  There have been some instances of lockstep protocol being implemented in the browser for use in videogames, (littlewargame.com, as an example) but these implementations have all been tied to the software that uses them, and a general protocol implementation had not yet been implemented.
  
  APPROACH:
  The intention with the design of the protocol was to have users connect to a server, download the lockstep code, and then network together in a peer to peer relationship. The lockstep protocol is similar to that proposed by Mark Terrano, Paul Bettner. The first step in making this possible was to build a consistent set of commands overtop of the webrtc and websocket functions to make the server and peer code easier to implement. for this small wrappers were created on top of PeerJS and Socket.io. PeerJS is a webrtc connection API, and Socket.io is a server client API. these were combined resulting in a single set of functions used to send and recieve messages from peer to peer, server to client, and client to server. These are the following:

  setConnect(function(id)) : the argument function runs whenever a connection is established. if the connection is server to client, the client setConnect function will be called with the id "Server". all other connections will recieve the unique peer id that PeerJS uses to handle connections.

  setDisconnect(function(id)) : called during a disconnect. 

  setRecv(function(id,data)) : called whenever data is recieved. the data field contains the data item being sent.

  send(id,data) : used to send data to peers or to the server.

  This set of functions are implemented in two javascript objects, ServerP.js and ClientP.js.
  Having this simple set of commands unified between all types of connections greatly expedited the next part of the implementation, the actual lockstep protocol.
  While the details of the protocol become a little involved, the resulting wrapper implementation is surprisingly simple. there are only two functions that must be used in order for an application to run the protocol. these are the following:

  setRunFunc(function(commands)) : this is the function that the protocol calls when it is time to advance the system state. the commands argument is filled in with a list of commands recieved from all peers.

  takeMove(tag,data): whenever the user intends to make a change to the program state, this function should be called instead of directly applying the changes. the lockstep protocol will store the commands and execute them in the next call of the run function.

  These functions are implemented in two other javascript objects, LSServer.js, which inherits from ServerP.js, and whose purpose is to initiate connections between peers, and LSPeer.js, which inherits from ClientP.js.
  The functional programming in Javascript allows these implementations to be so simple and modular. the Client and Server APIs could be implemented without knowing anything about the lockstep protocol, and the Lockstep protocol Client and Server could be implemented without knowing anything about the actual application it would be facilitating.
  This generalized and simple approach made creating the top layer applications relatively easy as well. There were two applications created to test the protocol, a simple collaborative drawing app, which can support any number of connected peers so long as the connection strength permits it, and a more complicated "air hockey" application that supports two players.
  One noteworthy challenge that was faced along the way pertained to the air hockey implementation. in the collision physics of the game, there was a function that converted the cartesian coordinates of the puck's velocity into polar coordinates using the Math.atan2 function, and back into cartesian coordinates using the Math.sin and Math.cos functions. This worked fine for a very brief game, or games that resided entirely on my computer, but upon testing the application with a friend's macbook and my computer, it was noticed that the pucks on our two computers became out of sync, to the point where we were both essentially playing different games.
  This was due to differences in the implementation of these trigonometric functions between our browsers. Once I rewrote the functions using dot products instead of switching to polar coordinates, the asynchrony problem was solved.

  IMPLEMENTATION AND RESULTS:
  Here we examine the implementation in more detail, first of the ServerP and ClientP objects, and then the LSServer and LSPeer objects that inherit from them.
  The ServerP object contains a single runServer function that starts a PeerJS server, a socket.io listener, and a http server. The http server hosts the actual client webpages. when a new client connects, the socket.io listener triggers the creation of a new PeerID for the client. this ID is sent to the client.
  The ClientP object upon first loading in the client browser sends a connection request to the server. Upon recieving back it's PeerID, it stores this value, and sets up it's own peersocket using this id.
  The ClientP object also contains a method for connecting to other Peers that takes the PeerID of the Peer to connect to.
  Once the initial server client connection is established, and/or Peer to Peer connections are established, the set of methods presented above can be used to define the interface of the Server and Peers.
  The LSServer code is short. it just contains a sendGameStart method, this method is called by the server with a list of IDs and a start time. this method alerts the Peers that it is time to begin a lockstep session, and all Peers will begin the session at the specified start time.
  the LSPeer code is where the actual protocol is implemented. The LSPeer contains a list of connected Peers that will be participating in the sessions, as well as two command lists. these lists store commands for tick t+1 and tick t+2. Peer commands are recorded for tick t+2, as they will not be sent until the end of the current tick, and need one tick to reach the other Peers. Because the timing of message sending will not always line up. commands recieved from other peers are put into one of these two lists, depending on the tick that they concern.
  There are two possiblities for the Peer at every tick, depending on whether other Peer commands for the next tick have been recieved. If they have not been recieved then the Peer will wait, and resend it's commands for the tick t+1. If they have been recieved, the peer will send the just recorded commands for tick t+2, and execute the run function, passing the commands for tick t+1.
  The one exception to this rule is at the very beginning of the session. at tick 0, the Peer runs the first tick even though it has not recived any commands for that tick, sends an empty set of commands for tick 1, and records moves for tick 2. on tick 1 this empty set of commands recieved from all peers is run, and the recorded commands for tick 2 are sent. finally on tick 2 the set of inputs recorded at tick 0are run. 
  Because of the imprecise timing, it is generally best to have Peers run new ticks as soon as possible to keep the system moving and reduce latency. with this in mind, the system has been coded such that peers that don't get to execute the run function on a given tick won't wait an entire tick to recieve commands, but will instead run as soon as all commands are recieved.
  I will finally go into a little detail on the two sample applications, the first is a simple drawing app. the app uses the HTML5 canvas. the canvas has a mouseclick and mousedrag listener. these listeners call the takeMove function of the LSPeer, which sends the actions to the other peers. Each peer keeps track of other Peer states based on these actions. for example peers must remember when each peer last clicked down to register the mouse drags as drawing and not just moving the mouse over the canvas. The end result is that multiple users can draw on the canvas simultaneously with a brief delay after actions.
  The airhockey implmentation also uses the HTML5 canvas, all that is sent between peers are mousedrag events. these are used to update the player paddle positions on the "table" a basic physics system was implemented to handle puck movement and bouncing off of paddles and walls, and at every tick the game checks if the puck is in a goal or not, and scores are displayed.

  RELATED WORK:
  As stated above, the lockstep implementation has been used in many videogames over the years. the most common example are real time strategy games, such as Age of Empires and Starcraft. these videogames feature hundreds to thousands of units interacting in an evolving state, and two to eight players sending commands to these units. The small number of peers and complicated state make this model very suitable for these types of games. One problem in any networked game is how to deal with latency, and lockstep is no exception to this. strategy games have many clever tricks for dealing with this issue, though they are mostly cosmetic. For example, to give the impression that units are immediately responding to commands, the game will often play a sound when an order is issued to give the player immediate feedback that the game has registered their move, and may even start the movement animation of the character model without actually changing the state of the game. None of these techniques were tried in the samples presented, although the lockstep implementation presented does not preclude this possibility.
  There is also the possility of cheating using the protocol. by implementing custom code, it is possible for users to simulate latency to gain advantages. For example, a peer could forego sending commands at first during every tick, and wait to see other peer inputs before making its own decision. As cheating is a common problem in multiplayer games, several potential solutions have been proposed: for example the program could send coded versions of commands to other Peers, that are only able to be decoded upon the peer sending their own set of commands for the turn, as is suggested by Ho Lee et al.

  CONCLUSION:
  The current lockstep implementation is very solid in some aspects: there is no way that the implementation will let one peer get way ahead of the other in terms of command execution, or that one peer might run a different set of commands from the other at a given tick. There are other parts that could certainly use some work, however. These mostly have to do with maintaining a stable connection and dealing with latency. in the current version of the model the only way to deal with high latency is to make the run function take longer and increase the time between ticks manually.
  An automatic method to accomplish this would be preferable. A potential solution could be to record how often the LSPeer has to wait for commands and stall execution, and send a command to other peers to increase the time between ticks if this becomes too often. To not slow down the application running as a result of the increased tick length, the run function could be looped multiple times instead of just once between ticks, thus advancing the state further. this would mean that the responsiveness of the program would decrease from a user perspective, but that may be preferable to slowdown.
  Additionally, the LSServer could be improved to present a lobby where clients could choose other clients interact with, rather than having the server automatically join peers as soon as enough join.
  The LSServer is also currently unable to deal properly with Peers quickly connecting and disconnecting, and can sometimes be tricked if this occurs too frequently. increasing the robustness of the server would be necissary in order to make the system reliable.
  Cheating prevention would have to also eventually be implemented, as it is possible for clients to inject their own javascript code into the execution that could alter the execution of the program.
  Implementing a checksum to check that states are synchronized would also be a good idea, especially for more complicated systems where there is some likelyhood of states becoming desynchronized.
  The potential applications that such a protocol could be used for are very large. essentially the protocol allows for the easy integration of several peer inputs into a single system state. 
  Some potential applications could be in design, as allowing multiple users to work in almost real time simultaneously on a project could make the exchange of creative ideas flow much more easily than by sending occasional updates. This was briefly explored with the drawing example.
  There is also the obvious application to game design, The implementation combined with the HTML5 canvas allows for easy distribution and networking of peers to experience multiplayer games.
  There may also be applications for the implementation that fall outside these categories, and have yet to be invented. It will be interesting to explore this potential.

  References:
  littlewargame.com (a javascript game that uses webrtc and lockstep to run a game between clients)

  Bettner P, Terrano M. GDC 2001: 1500 Archers on a 28.8: Network Programming in Age of Empires and Beyond

  Lee H, Kolowski E, Lenker S, Jamin S. IFIP 2003: Multiplayer Game Cheating Prevention with Pipelined Lockstep Protocol
